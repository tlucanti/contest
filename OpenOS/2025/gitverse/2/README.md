# Распределенное хранилище конфигурацией с использованием Git

## Возможности
- создание key-value пары ключей
- получение знвчение по имени ключа
- удаление ключа по имени
- возможность создание иерархии ключей: директорий
- распределенная система хранения с неограниченным количеством реплик
- система версионирования ключей и получения значений с любого коммита
- поддержка синхронизации с репликами с автоматическим разрешением конфликтов по стратегии last-write-wins
- вывод истории изменения для ключа

Поддерживаемые команды:
- `init`: инициализация репозитория
- `set`: создание или перезапись key-value пары
- `get`: получение значения по ключу с возможностью выбора ревизии
- `delete`: удаление key-value пары
- `node add`: добавление удаленного репозитория в качестве реплики
- `node delete`: прекращение синхронизации с репликой
- `sync`: синхронизация с репликой
- `sync-all`: синхронизация всех реплик
- `list`: получение списка ключей в директории
- `history`: получение истории изменений ключа

## Зависимости

 - Python 3.7+
   - `gitpython` (`pip3 install GitPython`)
 - Git

Установка зависимостей:
```bash
pip3 install GitPython
```

## Поддерживаемые команды

### `init` - Инициализация репозитория

Инициализирует Git-репозиторий в текущей директории (если ещё не создан) и делает первый коммит.

#### Параметры
```
python kvtool.py [-h] [--help] init
```

#### Пример использования
```bash
python kv.py init
```

---

### `set` - Установка значения пары key-value

Устанавливает значение для указанного ключа. Создаёт файл и коммитит изменения.

#### Параметры

```
python kv.py set [-h] [--help] key value
```
| Параметр | Описание |
|----------|----------|
| `key`    | Путь к файлу (ключ) |
| `value`  | Значение, которое будет записано в файл |

#### Пример использования

```bash
python kv.py set app/config/db_url "postgresql://localhost:5432/mydb"
```

---

### `get` - Получение значения ключа

Читает текущее значение ключа. При необходимости - из указанного коммита.

#### Параметры

```
python kvtool.py get [-h] [--help] key [--commit COMMIT]
```
| Параметр   | Описание |
|------------|----------|
| `key`      | Путь к файлу (ключ) |
| `--commit` | Хеш коммита, из которого нужно прочитать значение в Git формате (по умолчанию: `HEAD`) |

#### Пример использования
```bash
python kvtool.py get app/config/db_url
```

```bash
python kvtool.py get app/config/db_url --commit HEAD^^
```

---

### `delete` - Удаление ключа

Удаляет файл с указанным ключом и делает коммит.

#### Параметры

```
python kvtool.py delete [-h] [--help] key
```
| Параметр | Описание |
|---------|----------|
| `key` | Путь к файлу (ключ), который нужно удалить |

#### Пример использования

```bash
python kvtool.py delete app/config/db_url
```

---

### `node add` - Добавление удалённого репозитория

Добавляет удалённый репозиторий под именем `name`.

#### Параметры
```
python kvtool.py node add [-h] [--help] name repo_url
```
| Параметр    | Описание |
|------------|----------|
| `name`     | Имя создаваемой реплики |
| `repo_url` | URL репозитория |

#### Пример использования

```bash
python kvtool.py node add server git@github.com:user/config-server.git
```

```bash
python kvtool.py node add remote ../local-backup
```

---

### `node delete` - Удаление связи с удаленным репозиторием

Удаляет связь с репликой (но у реплики может остяться свзясь с текущим репозиторием)

#### Параметры

```
python kvtool.py node delete [-h] [--help] name
```

| Параметр | Описание |
|----------|----------|
| `name`   | Имя удаляемого узла |

#### Пример использования

```bash
python kvtool.py node delete remote
```

---
### `sync` - Синхронизация с репликой

Скачивает изменения с указанного удаленного репозитория, разрешает конфликты на основе last-write-win по каждому ключу, и отправляет обновлённую историю в удаленный репозиторий.

#### Параметры
```
python kvtool.py sync [-h] [--help] name
```
| Параметр | Описание |
|----------|----------|
| `name`   | Имя узла, с которым нужно синхронизироваться |

#### Пример использования

```bash
python kvtool.py sync remote
```

---

### `sync-all` - Синхронизация со всеми узлами

Выполняет `sync` для всех добавленных узлов.

#### Параметры
```
python kvtool.py sync-all
```

#### Пример использования

```bash
python kvtool.py sync-all
```

---

# Пример работы синхронизации:

```bash
# 1. Инициализация первой ноды
mkdir rep1 && cd rep1
python kv.py init
cd ..

# 2. Инициализация второй ноды
mkdir rep2 && cd rep2
python kv.py init
cd ..

# 3. Создание ключей по очереди в разных репликах
cd rep1
python kvtool.py set A 1
cd ..

cd rep2
python kvtool.py set A 2
python kvtool.py set B 1
cd ..

cd rep1
python kvtool.py set B 2
cd ..

# Полученная структура:
# time  rep1  rep2
#   0     -     -
#   1   A1      -
#   2   A1     A2
#   3   A1     A2,B1
#   4   A1,B2  A2,B1

# 4. Добавление репозитория в качестве реплики:
cd rep1
python kvtool.py node add remote ../rep2
cd ..

# 5. Для локального тестирования необходимо уйти с master ветки, чтобы git позволил пушить в remote ветку
cd rep2
git switch -C tmp
cd ..

# 6. Синхронизация с репликой
cd rep1
python kvtool.py sync-all
cd ..

# Полученная структура:
# time  rep1  rep2
#   0    -     -
#   2   A2     A2
#   4   A2,B2  A2,B2

```

# Объяснение реализации:

В commit message записывается timestamp, на основании которого принимается
решение о отбрасывании или принятии модификации

При синхронизации пары local-remote реплик находится общий предок
в совместной истории (LCA), так как более ранние коммиты совпадают -
нет смысла их рассматривать. При отсутствии LCA исследуется вся история
обоих реплик

Выполняется итерация по обоим ветвям LCA (меод двух указатей).
На каждой итерации выбирается тот коммит из двух указателей, у кого timestamp
меньше (т.е. коммит старше) - чтобы сохранять отсортированность коммитов
по timestamp

Далее введем понятие "Актуальная история" - это последовательность коммитов,
в рамках одной реплики
(с возрастающими timestamp), относящиеся только к одному ключу.
Причем такая последовательность, что последний коммит имеет самый большой
timestamp среди всех коммитов (над этим ключем) среди всех реплик.
Другими словами - это такая история, которая ведет к наиболее новому состоянию ключа

Для выбранного коммита узнаем какой ключ он модифицировал (каждый коммит
модифицирует ровно один ключ).
И далее выясняем - является ли данный коммит частью "Актуальной истории".
Для этого находим последние коммиты, затрагивающие ключ в выбранном коммите
в обоих ветвях LCA, И сравниваем их timestamp.

Если выбранный коммит не является частью "Актуальной истории", то он
отбрасывается (так как его история все равно будет перезаписана).
Если же является - то он применяется к результирующей истории

Таким образом формируется история коммитов для всех ключей, состаящая толбко
из Актуальных историй (в рамках двух реплик). Эта история перезаписывает
локальную и удаленную истории.

Выполнив подобные операции на всех парах реплик - можно гарантировать, что
все ключи не будут иметь устаревшее состояние, и новейшее состояние не
будет перезаписано в какой-либо из реплик
